---
title: "Principles"
---

eflows strives to be a declarative package and probably requires a lot of documentation. In this file I strive to write some of the principles that govern the API and the design of the package

## FAQ

### How does `eflow`


### But it is not R a functional language?

Yes, it is. Indeed, Object-Oriented Programming (OOP) as it is commonly understood is implemented as an afterthought in R. Indeed, there are un to four different implementations of OOP in R. Of them, the only one relevant for `eflows` is the one done with the package `R6`, that makes use of the very features of R to implement OOP in a way very approximate to languages like Java. 

![Structure](../../www/images/general/reference-value.gif)

Remarkably, the objects generated by the R6 (and thus, `e_frame` objects) have *reference semantics*, what is a rare occurence in R; as functional language, most of its objects have *value semantics*, namely the objects are immutable unless are explicity reassigned. 

### OOP plus FP? Is it not confusing?

Functional Programming style is indeed easy to understand, because the current state of the objects does not change no matter if part of the code in the script is run again. This makes it a very suitable style to work with data manipulation and transformation. 

OOP allows to change objects on the fly, without reassigning values. Although this can make the programming potentially confusing, there are a number of reasons eflows adopts the OOP: 

- The build of an `e_frame` object has to be quite strict. Other OOP in R, like `S3`, are easier to work with in a functional fashion, but do not allow the level of control and input verification that `R6` afford. 

- Wether in an script or in interactive mode, the whole point of OOP is to build progressively an `e_frame` object, and modify it with methods that can be conveniently chained. 

- Energy management software has been traditionally written in Java; perhaps it is not a good idea to depart from the OOP. 

To reduce as much the complexity of understanding the programming as much as possible, by design the methods of the `e_frame` objects behave in an "idempotent way", namely, an `e_frame` does not change if the same method is applied twice to it. 

Ultimately, the objective is to use OOP and FP in a synergistic way; instead of being opposite poles in a gradient, both programming styles can reinforce each other by managing the complexity of EMS. In short, the idea is to organize the data in objects, and then apply functions over the objects to obtain the best results. 




## Use of dataframes with the first column as POSIXt object {.test}

Time plays a vital role in eflows, yet the time series objects are not prefered. Instead, are used liberally data frames where the first column is time-based (and normally named "datetime"). This decision is taken for the sake of simplicity; a time series most of the times behaves like a data frame wehre the first column has different semantics. Where it is necessary to operate with actual time series, two helping functions to flip between data frames and time series are used: `df_to_ts` and `ts_to_df`

![Difference](../../www/images/general/difference.png)


## No stochastic
eflows is not a "black box"; it does not use any statistical approach to problem solving. This means that machine learning and lineal optimization methods are not considered in the core functions.    

![Structure](../../www/images/general/structure.png)

## Based on energy, not power
The energy flows are expressed on basis of kWh (the default unit to work with in the package), not kW or any other power unit. In principle kWh and kW are equivalent if the time step is one hour. This makes easier to read the changes in the battery: "25 kWh have flown, so the battery is charged with extra 25 kWh"




## Left-aligned
The time-based data is left aligned. This means that the changes in flows and battery soc reflect the change of the system once that time step has been concluded. In an hourly-based simulation, the flows that correspond to 14:00 are the ones happened between 14:00 and 15:00, and the soc of the batteries reflect their status once these energy flows have been resolved. 

## Prefixes and nomenclature
eflows strive to offer a consistent API to interact with energy flows. 

For instance, the prefix `ef_` connotes working with an eflows object, the basis for the package operations. Thus, after creating a first object with the function `ef_initialize`, different elements can be included in the model. 

A first distiction lies in the distiction between the functions prefixed with `add_` (The data is ready to be included in the model) and the functions prefixed with `gen_` (from "generate". The data is not readily available yet, but it is generated on the spot, thanks to the application of algorithms, normally involving randomness somehow)

Then, these functions are suffixed by the element in itself that refers to. These include: 

- `battery`, that unless stated otherwise, it refers to an stationary one. On some parts of the package, this is refered also as `batt`.
- `ev`, that stands for electric vehicles. This includes a number of factors, among them the battery and the soc available. When talking about batteries, the distinction between stationary batteries and electric vehicles batteries is signified with `batt` and `ev`.

- `infrastructure`: It refers both to the grid (which most important factor is the "grid capactiy", and the charging points `chp` in the jargon (and chaging stations `chs`, that are bundles of charging points)).(future: divide in two functions?)

- Electricity prices
- Misc, for random stuff that can be used with steering?

Once added the elements to the simulation, results can be generated using the function `ef_simulate`. This function uses the `steer` parameter to bundle the preferences for smart energy

- (future) `steer`: A term used to especify the algorithms that direct the energy flows between elements of the system. It includes factors as the preference for charge/discharge, use of Vehicle to Grid, charge thresholds etc. The steering can be very simple if it includes just default values, or very complex if it consists in functions that change over time and consider the forecast, too. 

Once the simulation has been run, there are a number of functions that easily visualize the results (using dygraphs), and that can be used both for exploratory anaysis and to include directly in websites using shiny. These functions are denoted with `graph_` For instance, `graph_flows`, `graph_ev` and else. Last, the functions prefixed by `display_` are used to modify the graph functions, adding new details or functionalities. 
